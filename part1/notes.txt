npx create-react-app part1
cd part1
npm start

Using in return array of components or 1 root element
root element are stipulated, and ugly... so we use fragments

return [
    <h1>Greetings</h1>,
    <Hello name="George" age={25 + 10} />,
    <Hello name="Tian" age="10" />,
];

variables:
const x = 1 is constant cannot be changed
const t = [1,2,3], then t.push(5) can be changed though,
why? array is object and variable points to same object, but content changes
let y = 5

useful methods/things:
- forEach: calls function for each of the items in aray
- concat: creates new array with old + new
- map: using old array, creates new array with function passed,
const m1 = t.map(v => v * 2)
- arrays can CHANGE TYPE, like int to strings
- destructuring assignment:
const t = [1,2,3,4,5]
const [first,second,...rest] = t
log(first,second) => 1,2
log(rest) => [3,4,5]
- object literals => {name:value}, can add properties on the fly like .adress=value
use object['secret numer']=1234 for special property names
- function declaration: function product(a,b) {} ...... result = product(2,4)
- function expression: const average = function(a,b) ........ average(2,4)
- function arrow: p => p * 2

Objects and this:
- this refers to object itself
- const temp = {
    greet: function() {
        console.log(this.name)
    },
    addition: function(a,b) {
        console.log(a+b)
    }
}
can call object: using temp.addition(1,2)
OR method reference: const referenceAddition = temp.addition
AND calling referenceAddition(1,2)
1st retains THIS, 2nd, method reference doesnt retain THIS.
***BECAUSE THIS DEPENDS ON HOW METHOD IS CALLED, so calling through reference
makes THIS become global object.
***fix by binding this to object like: arto.greet.bind(arto)
- dont use arrow functions with THIS (doesnt work at all)

Classes: not really classes, still only objects
class Person {
    constructor(name,age) {
        this.name = name
        this.age = age
    }
    greet() {
        console.log(this.name)
    }
}
const ADAM = new Person('Adam',12)
ADAM.greet()

we can destructure directly objects in arguments of functions {a,b}:
const Hello = ({a,b}) => ...

RE-RENDERING
call render() method, but bad practice, if a component has props passed to it,
and props modified, refresh will take that into account even if prop changed
under component call < />
when state modified function called, component re-executed as whole and rerendered

Event handlers

Philosophy:
- specialized componenents reused form complex app
- react uses functional programming => immutable data,
so if wants new array, not push, but concat with creates new array (old+new)
const t = [1,2,3]
const t2 = t.concat(5)

questions:
- array needs to have same type?